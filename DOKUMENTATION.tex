\documentclass[12pt, a4paper]{article}

% ── Pakete ──────────────────────────────────────────────────────────────────────
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{parskip}

\geometry{margin=2.5cm}

% ── Code-Styling ────────────────────────────────────────────────────────────────
\definecolor{codebg}{HTML}{F5F5F5}
\definecolor{codeframe}{HTML}{CCCCCC}
\definecolor{keyword}{HTML}{0077AA}
\definecolor{string}{HTML}{669900}
\definecolor{comment}{HTML}{999999}

\lstset{
  backgroundcolor=\color{codebg},
  frame=single,
  rulecolor=\color{codeframe},
  basicstyle=\ttfamily\small,
  keywordstyle=\color{keyword}\bfseries,
  stringstyle=\color{string},
  commentstyle=\color{comment}\itshape,
  breaklines=true,
  showstringspaces=false,
  tabsize=2,
  captionpos=b,
  aboveskip=10pt,
  belowskip=10pt
}

% ── Dokument-Info ───────────────────────────────────────────────────────────────
\title{\textbf{Music Locker} \\ \large Programmdokumentation}
\author{Musikempfehlungs-System mit MongoDB und Neo4j}
\date{\today}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

% ════════════════════════════════════════════════════════════════════════════════
\section{Überblick}
% ════════════════════════════════════════════════════════════════════════════════

\textbf{Music Locker} ist eine Musikempfehlungs-Webanwendung, die zwei Datenbanksysteme kombiniert: \textbf{MongoDB} (Dokumentendatenbank) und \textbf{Neo4j} (Graphdatenbank).

\subsection{Anwendungsszenario}

Nutzer können sich registrieren, Musik durchsuchen (Künstler, Alben, Tracks), Songs liken, Playlisten erstellen und personalisierte Empfehlungen erhalten. Das Empfehlungssystem basiert auf \textbf{Stimmungen (Moods)}: Wenn ein Nutzer Songs mit bestimmten Moods liked, werden ihm ähnliche Songs mit überlappenden Moods vorgeschlagen.

\subsection{Kernfunktionen}

\begin{itemize}
  \item \textbf{Benutzerverwaltung}: Registrierung, Login (JWT), Rollensystem (Admin/User)
  \item \textbf{Musikverwaltung}: CRUD für Künstler, Alben, Tracks mit Mood-Tags
  \item \textbf{Soziale Features}: Nutzer folgen, öffentliche Playlisten teilen
  \item \textbf{Likes \& Empfehlungen}: Mood-basiertes Empfehlungssystem über Neo4j-Graph
  \item \textbf{Dashboard}: Echtzeit-Genre-Statistik, beliebte Tracks, personalisierte Empfehlungen
\end{itemize}

% ════════════════════════════════════════════════════════════════════════════════
\section{Installation}
% ════════════════════════════════════════════════════════════════════════════════

\subsection{Voraussetzungen}

\begin{itemize}
  \item \textbf{Docker Desktop} (oder Docker Engine + Docker Compose) für MongoDB und Neo4j
  \item \textbf{Node.js} (v18+) und \textbf{npm} (für Backend und Frontend)
\end{itemize}

\subsection{Datenbanken mit Docker starten}

Im Projektordner liegt eine \texttt{docker-compose.yml}, die MongoDB und Neo4j konfiguriert:

\begin{lstlisting}[language=bash, caption={docker-compose.yml}]
version: '3.8'
services:
  mongodb:
    image: mongo:7.0
    container_name: musik_mongodb
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db
    environment:
      - MONGO_INITDB_DATABASE=musikempfehlung

  neo4j:
    image: neo4j:5.24
    container_name: musik_neo4j
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      - NEO4J_AUTH=neo4j/neo4jpassword
    volumes:
      - neo4j_data:/data

volumes:
  mongo_data:
  neo4j_data:
\end{lstlisting}

Container starten:

\begin{lstlisting}[language=bash]
docker-compose up -d
\end{lstlisting}

Prüfen, ob die Container laufen:

\begin{lstlisting}[language=bash]
docker ps
\end{lstlisting}

MongoDB läuft dann auf \texttt{localhost:27017}, Neo4j auf \texttt{localhost:7687} (Graph-Browser: \texttt{http://localhost:7474}).

\subsection{Umgebungsvariablen prüfen}
Im Ordner \texttt{backend} liegt bereits die fertige \texttt{.env}-Datei für das Uni-Projekt. Diese wurde für die einfache Ausführung absichtlich mit ins Repository gepackt.

Sie enthält folgende Konfiguration:
\begin{lstlisting}
PORT=5000
MONGO_URI=mongodb://localhost:27017/musikempfehlung
NEO4J_URI=bolt://localhost:7687
NEO4J_USER=neo4j
NEO4J_PASS=neo4jpassword
JWT_SECRET=super_secret_key_123
JWT_EXPIRES_IN=24h
\end{lstlisting}

\subsection{Datenbanken starten}
Die Container im Hintergrund (\texttt{-d}) starten (Docker Desktop muss laufen!):
\begin{lstlisting}[language=bash]
docker-compose up -d
\end{lstlisting}

\subsection{Backend und Frontend starten}
Starten Sie beide Server manuell in zwei separaten Terminal-Fenstern. Installieren Sie zuerst die Abhängigkeiten:

\textbf{Terminal 1 (Backend):}
\begin{lstlisting}[language=bash]
cd backend
npm install
npm run dev
\end{lstlisting}

\textbf{Terminal 2 (Frontend):}
\begin{lstlisting}[language=bash]
cd frontend
npm install
npm start
\end{lstlisting}

\subsubsection*{Datenbank mit Testdaten befüllen (einmalig)}
\begin{lstlisting}[language=bash]
node src/seed.js
\end{lstlisting}
Dieser Befehl erstellt Testdaten in MongoDB (Users, Artists, Albums, Tracks, Moods) und die zugehörigen Nodes/Beziehungen in Neo4j.

\subsection{Erreichbarkeit}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Dienst} & \textbf{URL} \\
\midrule
Frontend (React) & \texttt{http://localhost:3000} \\
Backend (API) & \texttt{http://localhost:5000} \\
Neo4j Browser & \texttt{http://localhost:7474} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Standard-Login}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Rolle} & \textbf{E-Mail} & \textbf{Passwort} \\
\midrule
Admin & \texttt{admin@musiclocker.com} & \texttt{admin123} \\
User & \texttt{anna@example.com} & \texttt{password123} \\
\bottomrule
\end{tabular}
\end{table}

% ════════════════════════════════════════════════════════════════════════════════
\section{Architektur}
% ════════════════════════════════════════════════════════════════════════════════

\subsection{Gesamtarchitektur}

Die Anwendung folgt einer klassischen \textbf{3-Schichten-Architektur}:

\begin{lstlisting}
+---------------------------------------------+
|           Frontend (React)                  |
|       http://localhost:3000                 |
| Pages: Dashboard, Tracks, Artists,          |
| Albums, Playlists, Moods, Users, Neo4jView  |
+---------------------+-----------------------+
                      | REST API (JSON)
+---------------------v-----------------------+
|         Backend (Express.js)                |
|         http://localhost:5000               |
|  Routes: /api/users, /api/tracks,           |
|  /api/neo4j, /api/integration, ...          |
|  Auth: JWT Middleware                       |
+---------+---------------------+-------------+
          |                     |
+---------v---------+  +--------v----------+
|     MongoDB       |  |      Neo4j        |
|   Port 27017      |  |    Port 7687      |
|   (Dokumente)     |  |    (Graph)        |
+-------------------+  +-------------------+
\end{lstlisting}

\subsection{Zusammenspiel Frontend -- Backend -- Datenbanken}

\begin{enumerate}
  \item \textbf{Frontend $\rightarrow$ Backend}: React-Komponenten rufen REST-Endpunkte auf (\texttt{/api/...}). Authentifizierung erfolgt über JWT-Tokens im \texttt{Authorization}-Header.
  \item \textbf{Backend $\rightarrow$ MongoDB}: Alle CRUD-Operationen für Stammdaten (Users, Artists, Albums, Tracks, Playlists, Moods).
  \item \textbf{Backend $\rightarrow$ Neo4j}: Beziehungen und Graph-Traversierungen (Likes, Follows, Mood-Verknüpfungen, Empfehlungen).
  \item \textbf{Integration}: Der \texttt{/api/integration/recommendations}-Endpunkt kombiniert beide Datenbanken -- Neo4j liefert Empfehlungs-IDs per Graph-Traversierung, MongoDB liefert die vollständigen Track-Details.
\end{enumerate}

\subsection{Begründung der Datenbank-Aufteilung}

\begin{table}[h]
\centering
\begin{tabular}{p{4cm}p{2.5cm}p{7cm}}
\toprule
\textbf{Daten} & \textbf{Datenbank} & \textbf{Begründung} \\
\midrule
Users, Artists, Albums, Tracks, Playlists, Moods & MongoDB & Komplexe Dokumente mit vielen Attributen (Name, E-Mail, Genre, Dauer etc.) -- ideal für dokumentenbasierte Speicherung \\
\midrule
LIKES, FOLLOWS, PERFORMED\_BY, HAS\_MOOD & Neo4j & Beziehungen zwischen Entitäten -- Graph-Traversierungen sind performanter als JOINs für Empfehlungsalgorithmen \\
\midrule
Empfehlungen & Beide & Neo4j traversiert den Graph, MongoDB liefert die Detail-Informationen \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Kerngedanke}: MongoDB speichert die \textbf{Stammdaten} (Was ist ein Track?), Neo4j speichert die \textbf{Beziehungen} (Wer liked was? Welcher Track hat welchen Mood?).

% ════════════════════════════════════════════════════════════════════════════════
\section{Datenmodelle}
% ════════════════════════════════════════════════════════════════════════════════

\subsection{MongoDB -- Collections}

\subsubsection{Collection: users}

\begin{lstlisting}[language=java, caption={Beispieldokument: users}]
{
  "userId": "user_001",
  "name": "Anna Schmidt",
  "email": "anna@example.com",
  "password": "$2b$10$...",
  "role": "user",
  "isActive": true,
  "favoriteGenres": ["Rock", "Pop"],
  "preferredMoods": ["Happy", "Energetic"],
  "following": ["user_002", "user_003"],
  "createdAt": "2026-01-15T12:00:00Z"
}
\end{lstlisting}

\subsubsection{Collection: artists}

\begin{lstlisting}[language=java, caption={Beispieldokument: artists}]
{
  "artistId": "art_001",
  "name": "Michael Jackson",
  "genre": "Pop",
  "bio": "King of Pop",
  "origin": "Gary, Indiana, USA",
  "formedYear": 1964,
  "createdBy": "user_001",
  "createdAt": "2026-01-15T12:00:00Z"
}
\end{lstlisting}

\subsubsection{Collection: albums}

\begin{lstlisting}[language=java, caption={Beispieldokument: albums}]
{
  "albumId": "alb_001",
  "artistId": "art_001",
  "title": "Thriller",
  "releaseYear": 1982,
  "genre": "Pop",
  "trackCount": 9,
  "duration_min": 42,
  "createdBy": "user_001",
  "createdAt": "2026-01-15T12:00:00Z"
}
\end{lstlisting}

\subsubsection{Collection: tracks}

\begin{lstlisting}[language=java, caption={Beispieldokument: tracks}]
{
  "trackId": "trk_001",
  "albumId": "alb_001",
  "artistId": "art_001",
  "title": "Billie Jean",
  "duration_sec": 294,
  "genre": "Pop",
  "mood": ["Energetic", "Mysterious", "Dark"],
  "createdBy": "user_001",
  "createdAt": "2026-01-15T12:00:00Z"
}
\end{lstlisting}

\subsubsection{Collection: playlists}

\begin{lstlisting}[language=java, caption={Beispieldokument: playlists}]
{
  "playlistId": "pl_001",
  "userId": "user_001",
  "name": "80s Classics",
  "description": "Die besten Songs der 80er",
  "trackIds": ["trk_001", "trk_002", "trk_004"],
  "isPublic": true,
  "createdBy": "user_001",
  "createdAt": "2026-01-15T12:00:00Z"
}
\end{lstlisting}

\subsubsection{Collection: moods}

\begin{lstlisting}[language=java, caption={Beispieldokument: moods}]
{
  "moodId": "mood_001",
  "name": "Happy",
  "description": "Froehliche, aufmunternde Musik",
  "keywords": ["joy", "cheerful", "bright"],
  "createdAt": "2026-01-15T12:00:00Z"
}
\end{lstlisting}

\subsection{Neo4j -- Node-Labels und Relationship-Typen}

\subsubsection{Node-Labels}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Label} & \textbf{Eigenschaften} & \textbf{Beschreibung} \\
\midrule
\texttt{User} & \texttt{userId} & Repräsentiert einen Benutzer \\
\texttt{Artist} & \texttt{artistId} & Repräsentiert einen Künstler \\
\texttt{Track} & \texttt{trackId} & Repräsentiert einen Song \\
\texttt{Album} & \texttt{albumId} & Repräsentiert ein Album \\
\texttt{Mood} & \texttt{moodId} & Repräsentiert eine Stimmung \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Relationship-Typen}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Beziehung} & \textbf{Von $\rightarrow$ Nach} & \textbf{Beschreibung} \\
\midrule
\texttt{LIKES} & User $\rightarrow$ Track & Nutzer hat einen Song geliked \\
\texttt{LIKES} & User $\rightarrow$ Album & Nutzer hat ein Album geliked \\
\texttt{FOLLOWS} & User $\rightarrow$ User & Nutzer folgt einem anderen Nutzer \\
\texttt{PERFORMED\_BY} & Track $\rightarrow$ Artist & Song wurde von Künstler aufgeführt \\
\texttt{HAS\_MOOD} & Track $\rightarrow$ Mood & Song hat diese Stimmung \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Beispielgraph}

Neo4j-Nodes enthalten \textbf{ausschließlich die Referenz-ID} -- keine Namen oder Titel. Die vollständigen Daten (Name, Titel etc.) werden über die ID aus MongoDB geladen. Dies wahrt die \textbf{referenzielle Integrität}: Daten existieren nur an einer Stelle (MongoDB) und werden nicht dupliziert.

\begin{lstlisting}
(:User {userId:"user_001"})--LIKES-->(:Track {trackId:"trk_001"})
                                           |
                                       PERFORMED_BY
                                           |
                                           v
                                  (:Artist {artistId:"art_001"})

(:Track {trackId:"trk_001"})--HAS_MOOD-->(:Mood {moodId:"mood_003"})
                                                    ^
                                                HAS_MOOD
                                                    |
                                          (:Track {trackId:"trk_015"})

(:User {userId:"user_001"})--FOLLOWS-->(:User {userId:"user_002"})
\end{lstlisting}

In diesem Beispiel würde das Empfehlungssystem dem User \texttt{user\_001} den Track \texttt{trk\_015} empfehlen, weil er den Mood \texttt{mood\_003} mit dem gelikten Track \texttt{trk\_001} teilt. Die zugehörigen Namen (z.B. \glqq Anna Schmidt\grqq{}, \glqq Billie Jean\grqq{}) werden erst über MongoDB aufgelöst.

% ════════════════════════════════════════════════════════════════════════════════
\section{Datenbankoperationen}
% ════════════════════════════════════════════════════════════════════════════════

\subsection{MongoDB -- CRUD-Befehle}

\subsubsection{Create (Einfügen)}

\begin{lstlisting}[language=java, caption={MongoDB: Neuen Track erstellen}]
await db.collection('tracks').insertOne({
  trackId: 'trk_xyz',
  title: 'Neuer Song',
  artistId: 'art_001',
  genre: 'Pop',
  mood: ['Happy', 'Energetic'],
  createdBy: 'user_001',
  createdAt: new Date()
});
\end{lstlisting}

\subsubsection{Read (Lesen)}

\begin{lstlisting}[language=java, caption={MongoDB: Daten abfragen}]
// Alle Tracks eines Genres filtern
await db.collection('tracks').find({ genre: 'Pop' }).toArray();

// Einen bestimmten Track finden
await db.collection('tracks').findOne({ trackId: 'trk_001' });

// Mehrere Tracks per ID-Array holen
await db.collection('tracks').find({
  trackId: { $in: ['trk_001', 'trk_002'] }
}).toArray();
\end{lstlisting}

\subsubsection{Update (Aktualisieren)}

\begin{lstlisting}[language=java, caption={MongoDB: Daten aktualisieren}]
// Track-Titel aendern
await db.collection('tracks').findOneAndUpdate(
  { trackId: 'trk_001' },
  { $set: { title: 'Neuer Titel' } },
  { returnDocument: 'after' }
);

// Nutzer folgen (ohne Duplikate mit $addToSet)
await db.collection('users').updateOne(
  { userId: 'user_001' },
  { $addToSet: { following: 'user_002' } }
);
\end{lstlisting}

\subsubsection{Delete (Löschen)}

\begin{lstlisting}[language=java, caption={MongoDB: Track löschen}]
await db.collection('tracks').deleteOne({ trackId: 'trk_001' });
\end{lstlisting}

\subsection{MongoDB -- Aggregation-Pipeline}

Die Genre-Statistik nutzt eine \textbf{Aggregation-Pipeline}, die Playlist-Tracks auflöst und nach Genre gruppiert:

\begin{lstlisting}[language=java, caption={MongoDB Aggregation-Pipeline: Genre-Statistik}]
await db.collection('playlists').aggregate([
  // 1. Nur Playlisten des aktuellen Users
  { $match: { userId: 'user_001' } },
  // 2. trackIds-Array aufloesen (ein Dokument pro Track-ID)
  { $unwind: '$trackIds' },
  // 3. Track-Details aus der tracks-Collection nachladen (JOIN)
  { $lookup: {
      from: 'tracks',
      localField: 'trackIds',
      foreignField: 'trackId',
      as: 'track'
  }},
  // 4. Lookup-Array aufloesen
  { $unwind: '$track' },
  // 5. Nach Genre gruppieren und zaehlen
  { $group: { _id: '$track.genre', count: { $sum: 1 } } }
]).toArray();
\end{lstlisting}

\textbf{Ergebnis-Beispiel:}

\begin{lstlisting}[language=java]
[
  { "_id": "Pop", "count": 5 },
  { "_id": "Rock", "count": 3 },
  { "_id": "Hip-Hop", "count": 2 }
]
\end{lstlisting}

\subsection{Neo4j -- CRUD-Befehle (Cypher)}

\subsubsection{Create (Nodes und Beziehungen)}

\begin{lstlisting}[caption={Neo4j Cypher: Nodes und Beziehungen erstellen}]
-- Neuen User-Node erstellen (MERGE verhindert Duplikate)
MERGE (u:User {userId: 'user_001'})

-- LIKES-Beziehung erstellen
MATCH (u:User {userId: 'user_001'}), (t:Track {trackId: 'trk_001'})
MERGE (u)-[:LIKES]->(t)

-- Track mit Artist-Beziehung erstellen
MATCH (t:Track {trackId: 'trk_001'})
MATCH (a:Artist {artistId: 'art_001'})
MERGE (t)-[:PERFORMED_BY]->(a)

-- Mood-Beziehung erstellen
MATCH (t:Track {trackId: 'trk_001'})
MATCH (m:Mood {moodId: 'mood_003'})
MERGE (t)-[:HAS_MOOD]->(m)

-- FOLLOWS-Beziehung erstellen
MATCH (u1:User {userId: 'user_001'})
MATCH (u2:User {userId: 'user_002'})
MERGE (u1)-[:FOLLOWS]->(u2)
\end{lstlisting}

\subsubsection{Read (Graph-Abfragen)}

\begin{lstlisting}[caption={Neo4j Cypher: Graph-Abfragen}]
-- Alle Tracks eines Kuenstlers
MATCH (t:Track)-[:PERFORMED_BY]->(a:Artist {artistId: 'art_001'})
RETURN t.trackId AS trackId

-- Alle gelikten Tracks eines Users
MATCH (u:User {userId: 'user_001'})-[:LIKES]->(t:Track)
RETURN t.trackId AS trackId

-- Beliebteste Tracks (nach Anzahl Likes sortiert)
MATCH (u:User)-[:LIKES]->(t:Track)
RETURN DISTINCT t.trackId AS trackId, COUNT(u) AS likeCount
ORDER BY likeCount DESC

-- Tracks mit einem bestimmten Mood
MATCH (t:Track)-[:HAS_MOOD]->(m:Mood {moodId: 'mood_003'})
RETURN t.trackId AS trackId
\end{lstlisting}

\subsubsection{Delete (Beziehungen und Nodes)}

\begin{lstlisting}[caption={Neo4j Cypher: Löschen}]
-- LIKES-Beziehung entfernen
MATCH (u:User {userId: 'user_001'})-[r:LIKES]->(t:Track {trackId: 'trk_001'})
DELETE r

-- FOLLOWS-Beziehung entfernen
MATCH (u1:User {userId: 'user_001'})-[r:FOLLOWS]->(u2:User {userId: 'user_002'})
DELETE r

-- Node und alle Beziehungen loeschen
MATCH (t:Track {trackId: 'trk_001'}) DETACH DELETE t
\end{lstlisting}

% ════════════════════════════════════════════════════════════════════════════════
\section{Integrations-Use-Case: Mood-basierte Musikempfehlungen}
% ════════════════════════════════════════════════════════════════════════════════

\subsection{Beschreibung}

Der zentrale Integrations-Use-Case ist das \textbf{Mood-basierte Empfehlungssystem}. Es kombiniert beide Datenbanken:

\begin{enumerate}
  \item \textbf{Neo4j} findet über Graph-Traversierung Tracks mit ähnlichen Moods
  \item \textbf{MongoDB} liefert die vollständigen Track-Details (Titel, Künstler, Genre, Dauer)
\end{enumerate}

\subsection{Ablauf (Schritt für Schritt)}

\begin{lstlisting}
+-----------+        +----------+        +---------+
| Frontend  |--(1)-->| Backend  |--(2)-->|  Neo4j  |
|           |        |          |        |  Graph  |
|           |        |          |--(4)-->| MongoDB |
+-----------+        +----------+        +---------+
     ^                                       |
     +-----------(6)--- Backend <---(3,5)----+
\end{lstlisting}

\textbf{Schritt 1}: Frontend ruft \texttt{GET /api/integration/recommendations/:userId} auf.

\textbf{Schritt 2}: Backend fragt Neo4j nach gelikten Tracks des Users:

\begin{lstlisting}[caption={Cypher: Gelikte Tracks abfragen}]
MATCH (u:User {userId: $userId})-[:LIKES]->(liked:Track)
RETURN liked.trackId AS trackId
\end{lstlisting}

\textbf{Schritt 3}: Neo4j traversiert den Graph -- findet Tracks mit überlappenden Moods:

\begin{lstlisting}[caption={Cypher: Empfehlungen berechnen}]
MATCH (u:User {userId: $userId})-[:LIKES]->(liked:Track)
      -[:HAS_MOOD]->(mood:Mood)
MATCH (mood)<-[:HAS_MOOD]-(recommended:Track)
WHERE NOT recommended.trackId IN $likedIds
RETURN recommended.trackId AS trackId,
       COUNT(DISTINCT mood) AS sharedMoods
ORDER BY sharedMoods DESC
LIMIT 10
\end{lstlisting}

Ergebnis: Liste von Track-IDs + Anzahl geteilter Moods (Score).

\textbf{Schritt 4}: Backend holt vollständige Track-Daten aus MongoDB:

\begin{lstlisting}[language=java, caption={MongoDB: Track-Details laden}]
await db.collection('tracks').find({
  trackId: { $in: trackIds }
}).toArray();
\end{lstlisting}

\textbf{Schritt 5}: Backend kombiniert Neo4j-Score mit MongoDB-Daten:

\begin{lstlisting}[language=java, caption={Integration: Daten zusammenfuehren}]
const enrichedRecommendations = recommendations.map(rec => {
  const track = tracks.find(t => t.trackId === rec.trackId);
  return {
    ...track,                     // Alle MongoDB-Details
    sharedMoods: rec.sharedMoods, // Neo4j-Score
    reason: `Teilt ${rec.sharedMoods} Moods mit deinen Lieblingssongs`
  };
});
\end{lstlisting}

\textbf{Schritt 6}: Frontend zeigt die Empfehlungen mit Titel, Künstler, Genre und Begründung an.

\subsection{Fallback-Strategie}

Falls ein Nutzer noch keine Tracks geliked hat, greift ein Fallback:

\begin{enumerate}
  \item \textbf{MongoDB} liefert die \texttt{preferredMoods} des Nutzers aus dem User-Profil
  \item \textbf{MongoDB} übersetzt Mood-Namen in Mood-IDs (\texttt{moods}-Collection)
  \item \textbf{Neo4j} findet Tracks mit diesen bevorzugten Moods
  \item \textbf{MongoDB} liefert wieder die Track-Details
\end{enumerate}

\subsection{Hybrid-Aggregation: Genre-Statistik}

Ein weiterer Integrations-Use-Case ist die \textbf{Genre-Statistik} auf dem Dashboard (\texttt{GET /api/playlists/stats/genres}). Diese kombiniert:

\begin{enumerate}
  \item \textbf{MongoDB Aggregation-Pipeline}: Zählt Genres aus den Playlisten des Users
  \item \textbf{Neo4j Cypher-Abfrage}: Holt die gelikten Track-IDs des Users
  \item \textbf{MongoDB Aggregation}: Zählt Genres der gelikten Tracks
  \item \textbf{Backend}: Merged beide Ergebnisse zu einer Gesamt-Genre-Statistik
\end{enumerate}

Diese hybride Abfrage zeigt, wie beide Datenbanken zusammenarbeiten, um ein vollständiges Bild des Musikgeschmacks zu erstellen.

\end{document}
